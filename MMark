## Array


## safari - bug

Safari bug — border-radius + overflow: hidden
Safari 上使用 border-radius 搭配 overflow: hidden 沒有圓角效果，這其實是 Safari 在呈現計算上的錯誤 [Bug]，可以藉由設定遮罩讓其重新計算。

範例程式碼：
element selector {
  border-radius: 10px;
  overflow: hidden;
  -webkit-mask-image: -webkit-radial-gradient(white, black);
}

或是設定 z-index 讓他重新計算堆疊位置，程式碼如下：
element selector {
  border-radius: 10px;
  overflow: hidden;
  position: relative;
  z-index: 0;
} 

## CSS 

1.隱藏數字輸入框 (Input Number) 的上下箭頭 (Arrows) 控制項

>> 撰寫網站時，難免都會替輸入框 (input) 設定自定義樣式，有時就會需要隱藏原先輸入框 (input) 的控制項。這邊紀錄網路上查找到，隱藏數字輸入框 (Input Number) 上下箭頭 (Arrows/Spinners) 控制項的方式。


程式碼

```
/* Chrome, Safari, Edge, Opera */
input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

/* Firefox */
input[type=number] {
  -moz-appearance: textfield;
}
```

深拷贝&浅拷贝
Json.prarse
Json.stringfy



## Swiper 插件

/*注意*/
1.同时展示多个swiper时候，swiper容器和翻页切换要加唯一id
2.navigation 翻页按钮要和html 的class一致 

```
pagination: {
  el: `.swiper-pagination-${$postion}`,
},
navigation: {
  nextEl: `.box_next-${$postion}`,
  prevEl: `.box_prev-${$postion}`, 
},

<div className={`${cStyles.btn_area_box}`}>
  <div className={`${cStyles.set_prev} s-button-prev`}>
    <SvgIcons xlinkHref={`#iconangle_left`} />
  </div>
  <div className={`${cStyles.set_next} s-button-next`}>
    <SvgIcons xlinkHref={`#iconarrgle_right`} />
  </div>
</div>

```
##  用两个问号做判断 ?? 
判断如果前者无数据的时候给一个默认值，不需要三目运算了
```
let 321 ?? {}
```



## 单页面应用Redux 不共享
缓存是共享的，redux不共享


## Safari 静音播放Video机制
这个场景是结合Swiper模拟抖音的视频播放，因为Safari默认静音，在视频加载的时候再延迟播放已经晚了，另辟蹊跷：视频参数配置  默认开声音不播放，在Swiper的onSlideChangeTransitionEnd渲染组件重新赋值， 以及 onTouchStart 事件中延时加载，从swiper返回切换后的视频索引，重新赋值，当索引值变化时候执行播放事件MyVideo.play(),有做延迟操作的话要把poster设置为图片，防止看到卡顿重播的现象。** 注意src才会实时更新视频资源，如果是source不会即使更新视频资源，会显示上一个。

### React & TypeScript
```
const videoDom = createRef(); //react 的ref等于当前视频元素
const MyVideo = videoDom.current;
MyVideo.play()

const playStyle = () => {
  return {
    muted: false,
    controls: false,
    autoPlay: false,
    preload: "metadata",
    loop: true,
  };
};
const setStyle = () => {
  return {
    width: "100%",
    height: "100%",
  };
};

<video
  id={`my-video-${aIndex}`}
  className="video-js"
  playsInline={true}
  webkit-playsinline="true"
  ref={ref}
  {...setObj}
  {...setCss}
  poster={vPosterImg}
  src={`${vVideoUrl}?v=1`}
/>
```

## 文字单行超出隐藏
```
text-overflow: ellipsis;
white-space: nowrap;
word-break: keep-all;
```

## 节流  &&  防抖
```
export function throttle() {
  let prev = Date.now();
  return function (func, delay) {
    const context = this;
    const args = arguments;
    const now = Date.now();
    if (now - prev >= delay) {
      func.apply(context, args);
      prev = Date.now();
    }
  };
}
export function debounce() {
  let handle;
  return function (fn, time) {
    clearTimeout(handle);
    handle = setTimeout(() => {
      fn.call(this);
    }, time || 50);
  };
}
```

## 价格补零
```
export function addZero(num) {
  num += "";
  num = num.replace(/[^0-9|\.]/g, "");
  if (/^0+/) num = num.replace(/^0+/, "");
  if (!/\./.test(num)) num += ".00";
  if (/^\./.test(num)) num = `0${num}`;
  num += "00";
  num = num.match(/\d+\.\d{2}/)[0];
  return num;
}
```
## 

## 格式化区域内滚动条
1.最外层固定宽、高
2.滚动区域固定宽、高。在滚动区域上面加滚动条的样式
3.overflow-y: overlay; 可以隐藏滚动条的占位，scroll 或 auto 会显示占位

```
    .right_cont{
       &::-webkit-scrollbar {
            width: 7px;
            /*竖向滚动条的宽度*/
            height: 1px;
            /*横向滚动条的高度*/
        }
       &::-webkit-scrollbar-thumb {
        /*滚动条里面的小方块*/
        background: #222;
      }

      &::-webkit-scrollbar-track {
          /*滚动条轨道的样式*/
          background: #444;
      }
    }
```

## 清除弹窗的虚边

```
.modal {
    height: 600px;
    background-color: #fff;
    position: fixed;
    top: 50%;
    left: 50%;
    -webkit-transform: translate(-50%, -50%);
    -moz-transform: translate(-50%, -50%);
    transform: translate(-50%, -50%);
    z-index: 99;
    border-radius: 16px;
    max-height: 90vh;
}
.modal:focus {
    outline: none;
}

.modal::-moz-focus-inner {
    border: 0;
}
.insImg::selection {
    background-color: transparent;
}

```

## CSS 三角形
通常是做气泡类的小三角，相对于父级定位

```
.filler_corner{
      position: absolute;
      bottom: -1em;
      left: 1.2rem;
      &::after {
          content: "";
          width: 0;
          border-left: 12px solid transparent;
          border-right: 12px solid transparent;
          border-bottom: 12px solid #EBEBEB;
      }
  }
```

## 匹配url查询参数
```
const getParamValue = function(url,key){
    let regex = new RegExp(key+"=([^&]*)","i");
    return url.match(regex)[1];

}
getParamValue(window.location.href,"id")
```


## Swiper 组件封装
```

```

# Using the React-Redux Bindings

## Using Redux with React
Redux can be used with any UI layer (such as Angular, Vue, or plain JS), but is most commonly used with React. The official React-Redux package provides bindings between React and Redux.

The connect function generates wrapper "container" components that subscribe to the store, so you don't have to write store subscription code for every component that needs to talk to the store.

Any component in your application can be wrapped with connect and "connected" to the store. Connecting more components is usually better for performance.

Finally, putting a <Provider> component around your root component makes the store accessible to all connected components.

## What Does connect Do?

Automatically handles subscribing to the store, and helps dispatch actions
Performance optimizations - automatically implements shouldComponentUpdate, and only re-renders your component when the data it needs changes.
Separates "subscribing to the store" from "what store am I subscribing to, and where did it come from?"
Helps keep your React components "unaware" of Redux.

## Why Use React-Redux?
There's no reason to write repetitive store subscription logic in every component. connect handles that for you automatically.
connect does a lot of work to ensure your real component only re-renders when it actually needs to. If you hand-write subscription code, your component will probably re-render too often.
Manually importing the store ties your components to that specific store instance, making it harder to test them. React-Redux's <Provider> acts as a lightweight dependency injection approach, which lets you reuse Redux-connected components and test them with a fake store if needed.
Your components will receive data and callback functions as props, same as any other React component would. This makes the more reusable.
Effectively all React+Redux apps use React-Redux, so that's what the documentation, articles, and community all refer to.

## 评论数、点赞数 显示K+ w+ 999w+
单位转化为k（千）或 w（万）,并保留一位小数
1e3为10的三次幂=1000 1e4=10000
```
function formatNumber(num){
    return num >= 1e3 && num < 1e4 ? (num / 1e3).toFixed(1) + 'k' : num >= 1e4 ? (num / 1e4).toFixed(1) + 'w' : num   
}
```

